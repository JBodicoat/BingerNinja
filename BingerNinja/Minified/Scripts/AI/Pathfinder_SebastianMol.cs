using System.Collections.Generic;using Unity.Mathematics;using UnityEngine;using UnityEngine.Tilemaps;public class Node{public Node QA = null;public float QS = 0, QD = 0, QF = 0;public bool QG;public Vector2Int QH;public Node(bool QJ, Vector2Int QK) { QG = QJ; QH = QK; }public void QL(){QS = 0;QD = 0;QF = 0;QA = null;}}public class Pathfinder_SebastianMol : M{const float QZ = 1;const float QX = 1.414f;Node[,] QC;public Tile[] QV;public Tilemap QB;int QN = 0;public Vector2Int QM;public Vector2Int WQ;public Tile WW;public List<Vector2Int> WE(Vector2Int WR, Vector2Int WT){Node a = QC[WR.x, WR.y];Node b = QC[WT.x, WT.y];List<Node> q = new List<Node>();List<Node> w = new List<Node>();List<Node> e = new List<Node>();Node r = a;if (a == b) return new List<Vector2Int>();q.Add(r);while (r != b){w.Add(r);q.Remove(r);for (int y = -1; y <= 1; y++){for (int x = -1; x <= 1; x++){if (x == 0 && y == 0) continue;Vector2Int WU = new Vector2Int(r.QH.x + x, r.QH.y + y);if (WY(WU)) continue;if (QC[WU.x, WU.y].QG == false) continue;if (w.Contains(QC[WU.x, WU.y])) continue;if (math.abs(x) == math.abs(y)){if (!QC[WU.x - x, WU.y].QG) continue;if (!QC[WU.x, WU.y - y].QG) continue;}float WO = (math.abs(x) == math.abs(y)) ? QX : QZ;if (q.Contains(QC[WU.x, WU.y])){if (r.QS + WO < QC[WU.x, WU.y].QS){QC[WU.x, WU.y].QA = r;QC[WU.x, WU.y].QS = r.QS + WO;QC[WU.x, WU.y].QF = QC[WU.x, WU.y].QS + QC[WU.x, WU.y].QD;}}else {QC[WU.x, WU.y].QA = r;QC[WU.x, WU.y].QS = r.QS + WO;QC[WU.x, WU.y].QD = math.abs(b.QH.x - WU.x) + math.abs(b.QH.y - WU.y);QC[WU.x, WU.y].QF = QC[WU.x, WU.y].QS + QC[WU.x, WU.y].QD;q.Add(QC[WU.x, WU.y]);}if (QC[WU.x, WU.y] == b){w.Add(QC[WU.x, WU.y]);r = b;}}}if (r == b) break;if (q.Count == 0) break;Node t = q[0];foreach (Node node in q){if (node.QF < t.QF) t = node;}r = t;}e = WP(r, e);if (e.Count == 0) return new List<Vector2Int>();if (e[0] != b) return new List<Vector2Int>();List<Vector2Int> m = new List<Vector2Int>();for (int i = e.Count - 1; i >= 0; --i){m.Add(new Vector2Int(e[i].QH.x, e[i].QH.y));}foreach (Node item in w) item.QL();foreach (Node item in q) item.QL();return m;}public void setTravercible(Vector2Int pos, bool trav){QC[pos.x, pos.y].QG = trav;}List<Node> WP(Node n, List<Node> a){if (QN<60){QN++;a.Add(n);if (n.QA != null) WP(n.QA, a);return a;}else {QN = 0;return a;}}bool WY(Vector2Int p){return p.x < 0 || p.x > QC.GetLength(0) - 1 || p.y < 0 || p.y > QC.GetLength(1) - 1 ? true : false;}void Start(){Vector3Int a = GetComponent<Tilemap>().size;QC = new Node[a.x, a.y];for (int y = 0; y < a.y; y++)for (int x = 0; x < a.x; x++){QC[x, y] = new Node(true, new Vector2Int(x, y));}QB = GetComponent<Tilemap>();for (int y = 0; y < QB.size.y; y++){for (int x = 0; x < QB.size.x; x++){for (int i = 0; i < QV.Length; i++){if (QB.GetTile(new Vector3Int(x, y, 0))){QC[x, y].QG = false;}}}}}}